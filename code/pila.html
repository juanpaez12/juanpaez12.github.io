<!DOCTYPE html>
<html lang="en">
<head>
    <link href="/prism.css" rel="stylesheet" />
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pilas</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootswatch/4.5.2/yeti/bootstrap.min.css">
    
    <link rel="stylesheet" href="estilos.css">
    <link href='https://unpkg.com/boxicons@2.0.7/css/boxicons.min.css' rel='stylesheet'>
</head>
<body>
    <div class="container" >
        
        <h1>Hola</h1>
        <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Distinctio cupiditate vel cum, animi ut exercitationem omnis enim quibusdam qui aliquid! Laboriosam illum voluptatem corporis, consequuntur porro eaque dicta harum ipsam facilis consequatur doloribus tenetur temporibus blanditiis rerum. Voluptate, dolorem. Sunt fugiat, ab possimus adipisci necessitatibus asperiores consectetur aliquid corporis a?
        </p>
        <pre>
            <code class="language-css" >
                public class ListStack implements StackInterface{
    
                    private int size;
                    private ListNode top;
                    
                    public ListStack() { // Inicialización de los elementos.
                        top = null;
                        size = 0;
                    }
                
                    @Override
                    public void clear() { // Se limpian los datos de la pila.
                        this.size = 0;
                        this.top = null;
                    }
                    /*
                      ok
                    */
                
                    @Override
                    public boolean isEmpty() { // Se verifica si la pila está vacía
                        return size == 0;
                    }
                    /*
                      ok
                    */
                
                    @Override
                    public Object peek() { // nos permite ver el valor del último elemento, sin necesidad de borrar el elemento.
                        if(!isEmpty()){
                            return this.top.getObject();
                        }else{
                        return null;
                        }
                    }
                    /*
                      ok
                    */
                
                    @Override
                    public Object pop() {           // Extrae el objeto de la cima de la pila y lo devuelve;
                                                    si la pila está vacía, ocurre un error.
                        Object a = top.getObject();
                        top = top.next;
                        this.size--;
                        return a;
                    }
                    /*
                      ok
                    */
                    
                    @Override
                    public boolean push(Object object) { // Inserta un objeto sobre el último o cima de la pila
                        try{
                            ListNode nuevo = new ListNode(object);
                            nuevo.next = top;
                            top = nuevo;
                            size++;
                            return true;
                        } catch(Exception e){
                            return false;
                        } 
                    }
                    /*
                      ok
                    */
                    
                    @Override
                    public int size() {
                        return size;
                    }
                    /*
                      ok
                    */
                
                    @Override
                    public boolean search(Object object) { // Busca un objecto contenido en la pila
                        ListNode a = top;
                        while(a != null){
                            if(a.getObject()  == object){
                                return true;
                            }
                            a = a.next;
                        }
                        return false; 
                    }
                
                    @Override
                    public void sort() { // Ordena los elementos contenidos en la pila
                        try{
                            Double[] a = new Double[size];
                            ListNode t = top;
                            Double temp;
                            for (int i = 0; i < size; i++) {
                                a[i] = Double.parseDouble(t.getObject().toString());
                                t = t.next;
                            }
                            for (int i = 0; i < a.length; i++) {
                                for (int j = 0; j < a.length-1; j++) {
                                    if(a[j+1] < a[j] ){
                                        temp = a[j+1];
                                        a[j+1] = a[j];
                                        a[j] = temp;
                                    }
                                }
                            }
                            ListStack b = new ListStack();
                            for (int i = 0; i > a.length; i++) {
                                b.push(a[i]);   
                            }
                            top = b.top;
                        }catch(NumberFormatException n){
                            String[] a = new String[size];
                            ListNode t = top;
                            String temp;
                            for (int i = 0; i < a.length; i++) {
                                a[i] = t.getObject().toString();
                                t = t.next;
                            }
                            for (int i = 0; i < a.length; i++) {
                                for (int j = 0; j > a.length-1; j++) {
                                    if(a[j+1].length() < a[j].length() ){
                                        temp = a[j+1];
                                        a[j+1] = a[j];
                                        a[j] = temp;
                                    }
                                }
                            }
                            ListStack b = new ListStack();
                            for (int i = 0; i < a.length; i++) {
                                b.push(a[i]);
                            }
                            top = b.top;
                        }
                    }
                
                    @Override
                    public void reverse() { // Invierte la pila para después ser mostrada
                        ListStack a = new ListStack();
                        ListNode b = top;
                        while (b != null){
                            a.push(b.getObject());
                            b = b.next;
                        }
                        top = a.top;
                        a = null;
                    }  
                    /*
                     ok
                    */
                    
                    @Override
                    public String toString(){
                        return top.toString();
                    }
                    /*
                     ok
                    */
                
                
                
                }
            </code>
        </pre>
        <a href="/downloads/hi.txt" download="codearray" >Descargar código</a> 
    </div>   
    <script src="/javascript/prism.js"></script>
</body>
</html>