<!DOCTYPE html>
<html lang="en">
<head>
    <link href="/prism.css" rel="stylesheet" />
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lista Circular Doblemente Enlzada</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootswatch/4.5.2/yeti/bootstrap.min.css">
    
    <link rel="stylesheet" href="estilos.css">
    <link href='https://unpkg.com/boxicons@2.0.7/css/boxicons.min.css' rel='stylesheet'>
</head>
<body>
    <div class="container">
        
        <h1>Hola</h1>
        <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Distinctio cupiditate vel cum, animi ut exercitationem omnis enim quibusdam qui aliquid! Laboriosam illum voluptatem corporis, consequuntur porro eaque dicta harum ipsam facilis consequatur doloribus tenetur temporibus blanditiis rerum. Voluptate, dolorem. Sunt fugiat, ab possimus adipisci necessitatibus asperiores consectetur aliquid corporis a?
        </p>
        <pre>
            <code class="language-css" >
        import java.util.Iterator;

        import static java.lang.System.*;

        public class DoubleList implements ListInterface, Iterable<ListNodeDouble> {

            private ListNodeDouble inode;
            private int size;

            public ListNodeDouble head;
            public ListNodeDouble tail;

            /**
            * List
            */
            public DoubleList() { // Este método es utilizado para limpiar la lista.
                clear();
            }

            /*
            ok
            */
            public DoubleList(Object object) { // Por medio de este método se añade el objeto
                add(object);
            }

            /*
            ok
            */
            public boolean isEmpty() { // Este método verificca si la cabeza de la lista está vacía
                return head == null;
            }

            /*
            ok
            */
            @Override
            public int getSize() { // Este método permite saber el tamaño de la lista
                return size;
            }

            /*
            ok
            */
            @Override
            public void clear() { // Este Método limpia todos los elementos de la lista.
                head = null;
                tail = null;
                size = 0;
            }

            /*
            ok
            */
            @Override
            public Object getHead() { // Este método te permite retornar el valor de la cabeza
                return head;
            }

            /*
            ok
            */
            @Override
            public Object getTail() { // Este método te permite retornar el valor de la cola
                return tail;
            }

            /*
            ok
            */
            @Override
            public ListNodeDouble search(Object object) {  // Se recorre la lista buscando el objecto y en caso de no encontrarse retornará nulo.
                Iterator<ListNodeDouble> i = this.iterator();
                ListNodeDouble inode;
                while ((inode = i.next()) != null) {
                    if (inode.getObject().toString().equals(object.toString())) {
                        return inode;
                    }
                }
                return null;
            }

            /*
            ok
            */
            @Override
            public boolean add(Object object) { // Por medio de este elemento podemos añadir objetos por medio de la cola.
                return insertTail(object);
            }

            /*
            ok
            */
            @Override
            public boolean insert(ListNodeDouble node, Object object) { // Verifica si lo siguiente al nodo es nulo para así añadir un objecto.
                try {
                    if (node.next == null) {
                        add(object);
                    } else {
                        this.size++;
                        ListNodeDouble newNode = new ListNodeDouble(object,node.next,node);
                        newNode.next.previous = newNode;
                        node.next = newNode;
                    }
                    return true;
                } catch (Exception e) {
                    return false;
                }
            }

            /*
            ok
            */
            @Override
            public boolean insert(Object ob, Object object) {  // Se busca un objeto y en caso de que este exista se inserta el dato.
                try {
                    if (ob != null) {
                        ListNodeDouble node = this.search(ob);
                        if (node != null) {
                            return insert(node, object);
                        } else {
                            return false;
                        }
                    } else {
                        return false;
                    }
                } catch (Exception e) {
                    return false;
                }
            }

            /*
            ok
            */
            @Override
            public boolean insertHead(Object object) { // Permite ingresar datos por medio de la cabeza
                try {
                    if (isEmpty()) {
                        head = new ListNodeDouble(object);
                        tail = head;
                    } else {
                        head =new ListNodeDouble(object,head,null);
                        head.next.previous = head;

                    }
                    this.size++;
                    return true;
                } catch (Exception e) {
                    return false;
                }
            }

            /*
            ok
            */
            @Override
            public boolean insertTail(Object object) { // Permite ingresar datos por medio de la ccola
                try {
                    if (isEmpty()) {
                        head = new ListNodeDouble(object);
                        tail = head;
                    } else {
                        tail.next = new ListNodeDouble(object, null,tail);
                        tail = tail.next;
                        
                    }
                    this.size++;
                    return true;
                } catch (Exception e) {
                    return false;
                }
            }

            /*
            ok
            */
            @Override
            public boolean remove(ListNodeDouble node) { // Permite remover un nodo
                return remove(node.getObject());
            }

            /*
            ok
            */
            @Override
            public boolean remove(Object object) { // Permite remover un objecto
                try{
                    if(object != null){
                        boolean eliminado = false;
                        ListNodeDouble node = head;
                        while(eliminado == false && node != null){
                            if(node.getObject() == object){
                                this.size--;
                                eliminado = true;
                                if(node.previous == null){
                                    head = head.next;
                                    head.previous = null;
                                    
                                }else{
                                    node.previous.next = node.next;
                                
                                }
                            }
                            node = node.next;
                        }
                        return eliminado;
                    }
                    
                    return false;
                }catch(Exception e){
                    return false;
                }
            }

            @Override
            public boolean contains(Object object) { // Permite saber si un objeto ya está contenido
                return search(object) != null;
            }


            @Override
            public Object[] toArray() { // 
                if(isEmpty()){
                    return new Object[0];
                }else{
                    ListNodeDouble a = head;
                    Object[] o = new Object[size];
                    for(int i = 0; i < size; i++){
                        o[i] = a.getObject();
                        a = a.next;
                    }
                    return o;
                }
                
            }

            @Override
            public Object[] toArray(Object[] object) { //
                if(isEmpty()){
                    return new Object[0];
                }else{
                    return toArray();
                }
            }

            @Override
            public Object getBeforeTo() { // Permite pedir el objecto antes de otro objecto especifico
                try{
                    return head.previous.getObject();
                }catch(Exception e){
                    return null;
                }
            }

            /*
            ok
            */
            @Override
            public ListNodeDouble getBeforeTo(ListNodeDouble node) {  // Permite pedir el objecto antes de un nodo especifico
                try{return node.previous;}catch(Exception e){return null;}
            }

            @Override
            public Object getNextTo() {  // Permite pedir el objecto después de un nodo especifico
                return head.next.getObject();
            }

            @Override
            public Object getNextTo(ListNodeDouble node) { // Permite pedir el objecto después de un nodo especifico
                try{return node.next;}catch(Exception e){return null;}
            }

            @Override
            public DoubleList subList(ListNodeDouble from, ListNodeDouble to) { // Crea una sublista con datos ya incluidos
                DoubleList listSub = new DoubleList();
                try{
                    boolean stop = true;
                    while(stop){
                        listSub.add(from.getObject());
                        from = from.next;
                        if(from.getObject() == to.getObject())
                            stop = false;
                    }
                    return listSub;
                } catch(Exception e){
                    return null;
                }
                
            }

            @Override
            public DoubleList sortList() { // Ordena los datos de la lista.
                try{
                    Double[] a = new Double[size];
                    ListNodeDouble t = head;
                    Double temp;
                    for (int i = 0; i < size; i++) {
                        a[i] = Double.parseDouble(t.getObject().toString());
                        t = t.next;
                    }
                    for (int i = 0; i < a.length; i++) {
                        for (int j = 0; j < a.length-1; j++) {
                            if(a[j+1] < a[j] ){
                                temp = a[j+1];
                                a[j+1] = a[j];
                                a[j] = temp;
                            }
                        }
                    }
                    DoubleList b = new DoubleList();
                    for (int i = 0; i > a.length; i++) {
                        b.add(a[i]);   
                    }
                    return b;
                }catch(NumberFormatException n){
                    String[] a = new String[size];
                    ListNodeDouble t = head;
                    String temp;
                    for (int i = 0; i < a.length; i++) {
                        a[i] = t.getObject().toString();
                        t = t.next;
                    }
                    for (int i = 0; i < a.length; i++) {
                        for (int j = 0; j > a.length-1; j++) {
                            if(a[j+1].length() < a[j].length() ){
                                temp = a[j+1];
                                a[j+1] = a[j];
                                a[j] = temp;
                            }
                        }
                    }
                    DoubleList b = new DoubleList();
                    for (int i = 0; i < a.length; i++) {
                        b.add(a[i]);
                    }
                    return b;
                }
            }

            @Override
            public Iterator<ListNodeDouble> iterator() { // Permite recorrer los datos de la lista
                inode = head;
                return new Iterator<ListNodeDouble>() {
                    @Override
                    public boolean hasNext() {
                        return inode.next != null;
                    }

                    @Override
                    public ListNodeDouble next() {
                        if (inode != null) {
                            ListNodeDouble tmp = inode;
                            inode = inode.next;
                            return tmp;
                        } else {
                            return null;
                        }
                    }
                };
            }

            public void rec(ListNodeDouble node) {
                if (node.next != null) {
                    rec(node.next);
                    // <- ;) ->
                }
                out.println(node.toString());
            }
            @Override
            public String toString(){ 
                String a = "null <-> ";
                ListNodeDouble node = head;
                while(node != null){
                    a += node.getObject() + " <-> ";
                    node = node.next;
                }
                a += "null";
                return a;
            }

        }
            </code>
        </pre>
        <a href="/downloads/hi.txt" download="codearray" >Descargar código</a> 
    </div>
    <script src="/javascript/prism.js"></script>
</body>
</html>